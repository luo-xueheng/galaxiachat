'use client';

import React, { useState, useEffect } from 'react';
import { Input, List, Avatar, Button, Space, message, Empty, Popover, Spin } from 'antd';
import { useSelector, useDispatch } from "react-redux";
import { useRouter } from "next/navigation";
import { setName, setToken } from "../redux/auth";
import type { GetProps } from 'antd';
import { RootState } from "../redux/store";
import { BACKEND_URL } from "../constants/string";
import { current } from '@reduxjs/toolkit';

type SearchProps = GetProps<typeof Input.Search>;

type Friend = {
  userName: string;
  avatar: string;
  is_friend: boolean;
  is_requested: boolean;
};
const PENDING_REQUESTS_KEY = 'pendingFriendRequests';
type UserInfo = {
  userName: string;
  avatar: string;
  email?: string;
  phone?: string;
  createdAt?: string;
};
type PendingRequest = {
  userName: string;
  request_id: string;
};

let ws: WebSocket | null = null;
const connectWebSocket = async (): Promise<WebSocket> => {
  const token = localStorage.getItem('token');
  if (!token) {
    throw new Error("‚ùå Token ‰∏çÂ≠òÂú®ÔºåÊó†Ê≥ïÂª∫Á´ã WebSocket ËøûÊé•");
  }

  return new Promise((resolve, reject) => {
    ws = new WebSocket(
      `wss://2025-backend-galaxia-galaxia.app.spring25b.secoder.net/ws/friend-request/?token=${encodeURIComponent(token)}`
    );

    ws.onopen = () => {
      console.log('‚úÖ WebSocket ËøûÊé•Â∑≤Âª∫Á´ã');
      resolve(ws);
    };

    ws.onerror = (error) => {
      console.error('‚ùå WebSocket ËøûÊé•ÈîôËØØ:', error);
      reject(error);
    };

    ws.onclose = () => {
      console.warn('‚ö†Ô∏è WebSocket ËøûÊé•Â∑≤ÂÖ≥Èó≠');
      ws = null;
    };
  });
};

const { Search } = Input;

const SearchUserPage: React.FC = () => {
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState<Friend[]>([]);
  const [selectedUserInfo, setSelectedUserInfo] = useState<UserInfo | null>(null);
  const [openPopoverUser, setOpenPopoverUser] = useState<string | null>(null);
  const [infoLoading, setInfoLoading] = useState(false);
  const router = useRouter();
  const userName = useSelector((state: RootState) => state.auth.name);
  const token = useSelector((state: RootState) => state.auth.token);
  const dispatch = useDispatch();

  useEffect(() => {
    const storedToken = localStorage.getItem("token");
    const storedUserName = localStorage.getItem("userName");

    if (storedToken) dispatch(setToken(storedToken));
    if (storedUserName) dispatch(setName(storedUserName));
    cleanPendingList
  }, [dispatch]);

  useEffect(() => {
    let socket: WebSocket | null = null;
  
    const initWebSocket = async () => {
      try {
        console.log("Ëé∑ÂèñÁî≥ËØ∑ÁªìÊûú");
        socket = await connectWebSocket();
        socket.onmessage = (event) => {
          console.log(event.data);
          const data = JSON.parse(event.data);
          console.log("üì® Êî∂Âà∞ WebSocket Ê∂àÊÅØÔºö", data);
  
          if (data.type === "friend_request_response") {
            const { receiver_name, status } = data;
  
            if (status === "accepted") {
              alert(`${receiver_name} Êé•Âèó‰∫Ü‰Ω†ÁöÑÂ•ΩÂèãËØ∑Ê±Ç`);
              // ‰ªé pendingFriendRequests ‰∏≠ÁßªÈô§ÂØπÊñπÁöÑÁî®Êà∑Âêç
              const updatedPending = getPendingRequests().filter(p => p.userName !== receiver_name);
              setPendingRequests(updatedPending);
              setResults(prev =>
                prev.map(user =>
                  user.userName === receiver_name
                    ? { ...user, is_friend: true, is_requested: false }
                    : user
                )
                
              );
              const currentUser = localStorage.getItem("userName");
              // ÊûÑÈÄ†ÂæÖÂà†Èô§ÁöÑ localStorage ÈîÆ
              const pendingRequestKey = `${PENDING_REQUESTS_KEY}_${currentUser}_${receiver_name}`;

              // Âà†Èô§ËØ•È°π
              localStorage.removeItem(pendingRequestKey);

              // ËæìÂá∫Êó•Âøó‰ª•Á°ÆËÆ§Âà†Èô§
              console.log("Removed pending request for", receiver_name, "with key", pendingRequestKey);
            } else if (status === "rejected") {
              alert(`${receiver_name} ÊãíÁªù‰∫Ü‰Ω†ÁöÑÂ•ΩÂèãËØ∑Ê±Ç`);
              // ‰ªé pendingFriendRequests ‰∏≠ÁßªÈô§ÂØπÊñπÁöÑÁî®Êà∑Âêç
              const updatedPending = getPendingRequests().filter(p => p.userName !== receiver_name);
              setPendingRequests(updatedPending);
              setResults(prev =>
                prev.map(user =>
                  user.userName === receiver_name
                    ? { ...user, is_friend: false, is_requested: false }
                    : user
                )
              );
              const currentUser = localStorage.getItem("userName");
              // ÊûÑÈÄ†ÂæÖÂà†Èô§ÁöÑ localStorage ÈîÆ
              const pendingRequestKey = `${PENDING_REQUESTS_KEY}_${currentUser}_${receiver_name}`;

              // Âà†Èô§ËØ•È°π
              localStorage.removeItem(pendingRequestKey);

              // ËæìÂá∫Êó•Âøó‰ª•Á°ÆËÆ§Âà†Èô§
              console.log("Removed pending request for", receiver_name, "with key", pendingRequestKey);
            }
          }
        };
      } catch (err) {
        console.error("WebSocket ÂàùÂßãÂåñÂ§±Ë¥•", err);
      }
    };
  
    initWebSocket();
  
    return () => {
      if (socket) {
        socket.close();
      }
    };
  }, []);
  

  const onSearch: SearchProps['onSearch'] = async (value) => {
    if (!value) return;
    setLoading(true);

    try {
      const res = await fetch(
        `${BACKEND_URL}/api/users/search?query=${encodeURIComponent(value)}`,
        {
          headers: {
            'Authorization': token,
          },
        }
      );

      const data = await res.json();
      const pendingList = getPendingRequests();
      //cleanPendingList(data.users); // ‚úÖ Ê∏ÖÁêÜÊú¨Âú∞ÁºìÂ≠ò
      if (data.users && Array.isArray(data.users)) {
        const merged = data.users.map((user: Friend) => ({
          ...user,
          is_requested: !user.is_friend && pendingList.some(p => p.userName === user.userName),
        }));
        cleanPendingList(data.users); // ‚úÖ Ê∏ÖÁêÜÊú¨Âú∞ÁºìÂ≠ò
        setResults(merged);
      } 
      else {
        message.warning('Ê≤°ÊúâÊêúÁ¥¢ÁªìÊûú');
        setResults([]);
      }
    } catch (err) {
      console.error("ÊêúÁ¥¢ËØ∑Ê±ÇÂ§±Ë¥•Ôºö", err);
      message.error('ËØ∑Ê±ÇÂ§±Ë¥•');
    } finally {
      setLoading(false);
    }
  };

  const fetchUserInfo = async (username: string) => {
    setInfoLoading(true);
    setSelectedUserInfo(null);
    setOpenPopoverUser(username);

    try {
      const res = await fetch(`${BACKEND_URL}/api/user/${username}`, {
        headers: {
          'Authorization': token,
        },
      });

      if (!res.ok) throw new Error('ËØ∑Ê±ÇÂ§±Ë¥•');
      const data = await res.json();
      setSelectedUserInfo(data);
    } catch (err) {
      console.error("Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•Ôºö", err);
      message.error("Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥•");
      setSelectedUserInfo(null);
    } finally {
      setInfoLoading(false);
    }
  };

  const addFriend = async (item: Friend) => {
    try {
      const socket = await connectWebSocket();

      const request = {
        action: "send_request",
        userName: item.userName,
        request_type: "direct",
      };
      socket.send(JSON.stringify(request));

      socket.onmessage = (event) => {
        try {
          const response = JSON.parse(event.data);
          console.log("ÂèëÁî≥ËØ∑Ôºö",event.data );
          if (response.status === "success") {
            alert(`Â•ΩÂèãËØ∑Ê±ÇÂ∑≤ÊàêÂäüÂèëÈÄÅÁªô ${item.userName}`);
          
            const request_id = response.request_id; // ‰ªéÂêéÁ´ØÂìçÂ∫î‰∏≠Ëé∑Âèñ
          
            const newPendingList = [
              ...getPendingRequests(),
              { userName: item.userName, request_id },
            ];
            setPendingRequests(newPendingList);
          
            setResults(prev =>
              prev.map(user =>
                user.userName === item.userName ? { ...user, is_requested: true } : user
              )
            );
          }
          //ËøôÈáåÊÄªÂú®Ëé´ÂêçËß¶Âèë
          // else {
          //   alert(`ÂèëÈÄÅÂ•ΩÂèãËØ∑Ê±ÇÂ§±Ë¥•: ${response.message || 'Êú™Áü•ÈîôËØØ'}`);
          // }
        } catch (e) {
          console.error('Ëß£ÊûêÂìçÂ∫îÂ§±Ë¥•:', e);
          alert('Â§ÑÁêÜÊúçÂä°Âô®ÂìçÂ∫îÊó∂Âá∫Èîô');
        }
      };
    } catch (error) {
      console.error('Ê∑ªÂä†Â•ΩÂèãÂ§±Ë¥•:', error);
      alert('ËøûÊé•ÊúçÂä°Âô®Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
    }
  };

  const getPendingRequests = (): PendingRequest[] => {
    try {
      const currentUser = localStorage.getItem("userName");
      if (!currentUser) return [];
      const data = localStorage.getItem(`${PENDING_REQUESTS_KEY}_${currentUser}`);
      console.log("pendingList", data);
      return data ? JSON.parse(data) : [];
    } catch {
      return [];
    }
  };
  const setPendingRequests = (requests: PendingRequest[]) => {
    const currentUser = localStorage.getItem("userName");
    if (currentUser) {
      localStorage.setItem(`${PENDING_REQUESTS_KEY}_${currentUser}`, JSON.stringify(requests));
    }
  };
  const cleanPendingList = (users: Friend[]) => {
    const pending = getPendingRequests(); // PendingRequest[]
  
    // ÊâæÂá∫‰æùÁÑ∂ÊòØ‚ÄúÊú™Âä†‰∏∫Â•ΩÂèã‚Äù‰ΩÜÂú® pending ÂàóË°®ÈáåÁöÑÁî®Êà∑
    const stillPending = pending.filter(p =>
      users.some(user => user.userName === p.userName && !user.is_friend)
    );
  
    // Âè™‰øùÁïôËøô‰∫õËøòÂú®Áî≥ËØ∑‰∏≠ÁöÑÁî®Êà∑
    setPendingRequests(stillPending);
  };
  const renderPopoverContent = () => {
    if (infoLoading) return <Spin />;
    if (!selectedUserInfo) return <div>Êú™ÊâæÂà∞‰ø°ÊÅØ</div>;

    return (
      <div>
        <p><strong>Áî®Êà∑Âêç:</strong> {selectedUserInfo.userName}</p>
        {selectedUserInfo.email && <p><strong>ÈÇÆÁÆ±:</strong> {selectedUserInfo.email}</p>}
        {selectedUserInfo.phone && <p><strong>ÁîµËØù:</strong> {selectedUserInfo.phone}</p>}
        {selectedUserInfo.createdAt && <p><strong>Ê≥®ÂÜåÊó∂Èó¥:</strong> {selectedUserInfo.createdAt}</p>}
      </div>
    );
  };

  return (
    <Space direction="vertical" style={{ width: '100%', padding: '24px' }}>
      <div style={{ fontWeight: 'bold', fontSize: '16px' }}>
    üë§ ÂΩìÂâçÁî®Êà∑Ôºö{userName}
      </div>
      <Button type="link" onClick={() => router.push('/mainpage')}>
    ‚Üê ËøîÂõû‰∏ªÈ°µ
  </Button>
      <Search
        placeholder="ÊêúÁ¥¢Áî®Êà∑Âêç"
        onSearch={onSearch}
        enterButton="Search"
        loading={loading}
        allowClear
      />

      {results.length === 0 ? (
        <Empty description="ÊöÇÊó†ÊêúÁ¥¢ÁªìÊûú" />
      ) : (
        <List
          itemLayout="horizontal"
          dataSource={results}
          renderItem={(item) => (
            <List.Item
              key={item.userName}
              actions={[
                <Space key="actions" size="middle">
                  <Button
                    type="primary"
                    onClick={() => addFriend(item)}
                    disabled={item.is_friend || item.is_requested}
                  >
                    {item.is_friend ? "Â∑≤Ê∑ªÂä†" : item.is_requested ? "Â∑≤Áî≥ËØ∑" : "Ê∑ªÂä†Â•ΩÂèã"}
                  </Button>

                  <Popover
                    title="Áî®Êà∑‰ø°ÊÅØ"
                    trigger="click"
                    open={openPopoverUser === item.userName}
                    onOpenChange={(visible) => {
                      if (visible) fetchUserInfo(item.userName);
                      else setOpenPopoverUser(null);
                    }}
                    content={renderPopoverContent()}
                  >
                    <Button type="default">Êü•Áúã‰ø°ÊÅØ</Button>
                  </Popover>
                </Space>,
              ]}
            >
              <List.Item.Meta
                avatar={<Avatar src={item.avatar} />}
                title={item.userName}
                description={item.is_friend ? "Â∑≤ÊòØÂ•ΩÂèã" : "Êú™Ê∑ªÂä†"}
              />
            </List.Item>
          )}
        />
      )}
    </Space>
  );
};

export default SearchUserPage;
